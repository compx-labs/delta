#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 4 1000000000000000 10000 22500
    bytecblock 0x0000000000000000 "rewards_paid" "platform_fees_accrued" "st" "admin_address" "reward_asset_id" "total_staked" "accrued_rewards" "reward_per_token" "contract_state" "last_update_time" "rewards_exhausted" "total_rewards" "num_stakers" "super_admin_address" "platform_fee_bps" "staked_asset_id" 0x0000000000000001 "master_repo_app" "reward_rate" "start_time" "apr_bps" 0x151f7c75
    // smart_contracts/staking/staking.algo.ts:24-25
    // @contract({ name: "staking", avmVersion: 11 })
    // export class Staking extends Contract {
    pushbytes 0x2487c32c // method "deleteApplication()void"
    txna ApplicationArgs 0
    match main_deleteApplication_route@2

main_switch_case_next@3:
    // smart_contracts/staking/staking.algo.ts:24-25
    // @contract({ name: "staking", avmVersion: 11 })
    // export class Staking extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@20
    pushbytess 0x7736a451 0x8264c98e 0x71bfff11 0x56134411 0xc3bd7ed4 0xda27004a 0xa3fea40f 0x6590467a 0x907df3f6 0x294d37e9 0x7a9ee189 0xa5ae6bd1 0x813ce89a 0x3172ca9d // method "initApplication(uint64,uint64,uint64,uint64,uint64,uint64,pay)void", method "fundRewards(axfer,uint64)void", method "fundMoreRewards(axfer,uint64)void", method "removeRewards()void", method "setContractActive()void", method "setContractInactive()void", method "updateAdminAddress(address)void", method "updateSuperAdminAddress(address)void", method "withdrawPlatformFees(address)void", method "emergencyWithdrawAsset(uint64,uint64,address)void", method "stake(axfer,uint64,pay)void", method "claimRewards()void", method "unstake(uint64)void", method "gas()void"
    txna ApplicationArgs 0
    match initApplication fundRewards fundMoreRewards removeRewards setContractActive setContractInactive updateAdminAddress updateSuperAdminAddress withdrawPlatformFees emergencyWithdrawAsset stake claimRewards unstake main_gas_route@18
    err

main_gas_route@18:
    // smart_contracts/staking/staking.algo.ts:566
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

main_create_NoOp@20:
    // smart_contracts/staking/staking.algo.ts:24-25
    // @contract({ name: "staking", avmVersion: 11 })
    // export class Staking extends Contract {
    pushbytes 0xcd19f1a6 // method "createApplication(address,uint64)void"
    txna ApplicationArgs 0
    match createApplication
    err

main_deleteApplication_route@2:
    // smart_contracts/staking/staking.algo.ts:538
    // @abimethod({ allowActions: "DeleteApplication" })
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be DeleteApplication && can only call when not creating
    b deleteApplication


// smart_contracts/staking/staking.algo.ts::Staking.createApplication[routing]() -> void:
createApplication:
    // smart_contracts/staking/staking.algo.ts:53
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:55
    // this.admin_address.value = adminAddress.native;
    uncover 2
    app_global_put
    // smart_contracts/staking/staking.algo.ts:47
    // contract_version = GlobalState<Uint64>();
    pushbytess "contract_version" 0x0000000000000fa0 // "contract_version", 0x0000000000000fa0
    // smart_contracts/staking/staking.algo.ts:56
    // this.contract_version.value = new Uint64(VERSION);
    app_global_put
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:57
    // this.contract_state.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:49
    // master_repo_app = GlobalState<Application>();
    bytec 18 // "master_repo_app"
    // smart_contracts/staking/staking.algo.ts:58
    // this.master_repo_app.value = masterRepoApp;
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:50
    // platform_fee_bps = GlobalState<Uint64>();
    bytec 15 // "platform_fee_bps"
    // smart_contracts/staking/staking.algo.ts:59
    // this.platform_fee_bps.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:60
    // this.platform_fees_accrued.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:61
    // this.rewards_paid.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:53
    // @abimethod({ allowActions: "NoOp", onCreate: "require" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.initApplication[routing]() -> void:
initApplication:
    // smart_contracts/staking/staking.algo.ts:64
    // @abimethod({ allowActions: "NoOp" })
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    cover 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    cover 3
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    cover 4
    txn GroupIndex
    intc_1 // 1
    -
    dup
    cover 5
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/staking/staking.algo.ts:74
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:74
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can init application");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only admin can init application
    // smart_contracts/staking/staking.algo.ts:75
    // assert(rewardAmount > 0, "Invalid reward amount");
    uncover 3
    assert // Invalid reward amount
    // smart_contracts/staking/staking.algo.ts:76
    // assert(duration > 0, "Invalid duration");
    assert // Invalid duration
    // smart_contracts/staking/staking.algo.ts:77
    // assert(aprBps > 0, "Invalid APR");
    swap
    assert // Invalid APR
    // smart_contracts/staking/staking.algo.ts:79
    // const start: uint64 = startTime === 0 ? Global.latestTimestamp : startTime;
    bnz initApplication_ternary_false@3
    global LatestTimestamp

initApplication_ternary_merge@4:
    // smart_contracts/staking/staking.algo.ts:80
    // const end: uint64 = start + duration;
    dup
    dig 3
    +
    // smart_contracts/staking/staking.algo.ts:81
    // assert(end > start, "Invalid time range");
    dig 1
    >
    assert // Invalid time range
    // smart_contracts/staking/staking.algo.ts:28
    // staked_asset_id = GlobalState<Uint64>();
    bytec 16 // "staked_asset_id"
    // smart_contracts/staking/staking.algo.ts:83
    // this.staked_asset_id.value = new Uint64(stakedAssetId);
    dig 10
    app_global_put
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:84
    // this.reward_asset_id.value = new Uint64(rewardAssetId);
    dig 8
    app_global_put
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:85
    // this.total_rewards.value = new Uint64(rewardAmount);
    dig 6
    app_global_put
    // smart_contracts/staking/staking.algo.ts:34
    // reward_rate = GlobalState<Uint64>();
    bytec 19 // "reward_rate"
    // smart_contracts/staking/staking.algo.ts:86
    // this.reward_rate.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:87
    // this.start_time.value = new Uint64(start);
    itob
    // smart_contracts/staking/staking.algo.ts:35
    // start_time = GlobalState<Uint64>();
    bytec 20 // "start_time"
    // smart_contracts/staking/staking.algo.ts:87
    // this.start_time.value = new Uint64(start);
    dig 1
    app_global_put
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:88
    // this.last_update_time.value = new Uint64(start);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:89
    // this.reward_per_token.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:90
    // this.total_staked.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:91
    // this.num_stakers.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:92
    // this.accrued_rewards.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:40
    // apr_bps = GlobalState<Uint64>();
    bytec 21 // "apr_bps"
    // smart_contracts/staking/staking.algo.ts:93
    // this.apr_bps.value = new Uint64(aprBps);
    dig 4
    app_global_put
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:94
    // this.platform_fees_accrued.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:95
    // this.rewards_exhausted.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:96
    // this.rewards_paid.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:98-101
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    dupn 2
    gtxns Receiver
    // smart_contracts/staking/staking.algo.ts:99
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:98-101
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    swap
    gtxns Amount
    // smart_contracts/staking/staking.algo.ts:100
    // amount: INITIAL_PAY_AMOUNT,
    pushint 400000 // 400000
    // smart_contracts/staking/staking.algo.ts:98-101
    // assertMatch(initialBalanceTxn, {
    //   receiver: Global.currentApplicationAddress,
    //   amount: INITIAL_PAY_AMOUNT,
    // });
    ==
    &&
    assert // assert target is match for conditions
    // smart_contracts/staking/staking.algo.ts:103-110
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:106
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:107
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 7
    dup
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:103-109
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:108
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:103-110
    // itxn
    //   .assetTransfer({
    //     xferAsset: stakedAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:112
    // if (rewardAssetId !== stakedAssetId) {
    dig 6
    !=
    bz initApplication_after_if_else@8
    // smart_contracts/staking/staking.algo.ts:113-120
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:116
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:117
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 5
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:113-119
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:118
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:113-120
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardAssetId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

initApplication_after_if_else@8:
    // smart_contracts/staking/staking.algo.ts:64
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

initApplication_ternary_false@3:
    dig 2
    b initApplication_ternary_merge@4


// smart_contracts/staking/staking.algo.ts::Staking.fundRewards[routing]() -> void:
fundRewards:
    // smart_contracts/staking/staking.algo.ts:124
    // @abimethod({ allowActions: "NoOp" })
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/staking/staking.algo.ts:126
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can fund rewards");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:126
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can fund rewards");
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Only admin can fund rewards
    // smart_contracts/staking/staking.algo.ts:127
    // assert(this.contract_state.value === new Uint64(0), "Pool must be inactive");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:127
    // assert(this.contract_state.value === new Uint64(0), "Pool must be inactive");
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // 0x0000000000000000
    ==
    assert // Pool must be inactive
    // smart_contracts/staking/staking.algo.ts:128
    // assert(this.accrued_rewards.value.asUint64() === 0, "Rewards already started");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:128
    // assert(this.accrued_rewards.value.asUint64() === 0, "Rewards already started");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    !
    assert // Rewards already started
    // smart_contracts/staking/staking.algo.ts:129
    // assert(rewardAmount === this.total_rewards.value.asUint64(), "Reward amount mismatch");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:129
    // assert(rewardAmount === this.total_rewards.value.asUint64(), "Reward amount mismatch");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 2
    ==
    assert // Reward amount mismatch
    // smart_contracts/staking/staking.algo.ts:131-136
    // assertMatch(rewardFundingTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    //   assetAmount: rewardAmount,
    // });
    dig 2
    gtxns Sender
    ==
    dig 2
    gtxns AssetReceiver
    // smart_contracts/staking/staking.algo.ts:133
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:131-136
    // assertMatch(rewardFundingTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    //   assetAmount: rewardAmount,
    // });
    ==
    &&
    dig 2
    gtxns XferAsset
    // smart_contracts/staking/staking.algo.ts:134
    // xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:134
    // xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:131-136
    // assertMatch(rewardFundingTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    //   assetAmount: rewardAmount,
    // });
    ==
    &&
    uncover 2
    gtxns AssetAmount
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:137
    // this.rewards_exhausted.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:124
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.fundMoreRewards[routing]() -> void:
fundMoreRewards:
    // smart_contracts/staking/staking.algo.ts:140
    // @abimethod({ allowActions: "NoOp" })
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/staking/staking.algo.ts:142
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can fund rewards");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:142
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can fund rewards");
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Only admin can fund rewards
    // smart_contracts/staking/staking.algo.ts:143
    // assert(rewardAmount > 0, "Invalid reward amount");
    dig 1
    assert // Invalid reward amount
    // smart_contracts/staking/staking.algo.ts:145-150
    // assertMatch(rewardFundingTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    //   assetAmount: rewardAmount,
    // });
    dig 2
    gtxns Sender
    ==
    dig 2
    gtxns AssetReceiver
    // smart_contracts/staking/staking.algo.ts:147
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:145-150
    // assertMatch(rewardFundingTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    //   assetAmount: rewardAmount,
    // });
    ==
    &&
    dig 2
    gtxns XferAsset
    // smart_contracts/staking/staking.algo.ts:148
    // xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:148
    // xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:145-150
    // assertMatch(rewardFundingTxn, {
    //   sender: this.admin_address.value,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.reward_asset_id.value.asUint64()),
    //   assetAmount: rewardAmount,
    // });
    ==
    &&
    uncover 2
    gtxns AssetAmount
    dig 2
    ==
    &&
    assert // assert target is match for conditions
    // smart_contracts/staking/staking.algo.ts:152
    // this.total_rewards.value = new Uint64(this.total_rewards.value.asUint64() + rewardAmount);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:152
    // this.total_rewards.value = new Uint64(this.total_rewards.value.asUint64() + rewardAmount);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    +
    itob
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:152
    // this.total_rewards.value = new Uint64(this.total_rewards.value.asUint64() + rewardAmount);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:153
    // this.rewards_exhausted.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:140
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.removeRewards[routing]() -> void:
removeRewards:
    // smart_contracts/staking/staking.algo.ts:158
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can fund rewards");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:158
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can fund rewards");
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    ==
    assert // Only admin can fund rewards
    // smart_contracts/staking/staking.algo.ts:159
    // assert(this.contract_state.value === new Uint64(0), "Pool must be inactive");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:159
    // assert(this.contract_state.value === new Uint64(0), "Pool must be inactive");
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // 0x0000000000000000
    ==
    assert // Pool must be inactive
    // smart_contracts/staking/staking.algo.ts:161
    // const available: uint64 = this.total_rewards.value.asUint64() - this.accrued_rewards.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:161
    // const available: uint64 = this.total_rewards.value.asUint64() - this.accrued_rewards.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:161
    // const available: uint64 = this.total_rewards.value.asUint64() - this.accrued_rewards.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    -
    // smart_contracts/staking/staking.algo.ts:162
    // assert(available > 0, "No rewards to remove");
    dup
    assert // No rewards to remove
    // smart_contracts/staking/staking.algo.ts:163-169
    // itxn.assetTransfer({
    //   xferAsset: this.reward_asset_id.value.asUint64(),
    //   assetReceiver: this.admin_address.value,
    //   sender: Global.currentApplicationAddress,
    //   assetAmount: available,
    //   fee: 0,
    // }).submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:164
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:164
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:166
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    uncover 2
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/staking/staking.algo.ts:163-169
    // itxn.assetTransfer({
    //   xferAsset: this.reward_asset_id.value.asUint64(),
    //   assetReceiver: this.admin_address.value,
    //   sender: Global.currentApplicationAddress,
    //   assetAmount: available,
    //   fee: 0,
    // }).submit();
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:168
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:163-169
    // itxn.assetTransfer({
    //   xferAsset: this.reward_asset_id.value.asUint64(),
    //   assetReceiver: this.admin_address.value,
    //   sender: Global.currentApplicationAddress,
    //   assetAmount: available,
    //   fee: 0,
    // }).submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:170
    // this.rewards_exhausted.value = new Uint64(1);
    bytec 17 // 0x0000000000000001
    app_global_put
    // smart_contracts/staking/staking.algo.ts:156
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.setContractActive[routing]() -> void:
setContractActive:
    // smart_contracts/staking/staking.algo.ts:175
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can set active");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:175
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can set active");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only admin can set active
    // smart_contracts/staking/staking.algo.ts:176-181
    // const superAdminResult = abiCall({
    //   appId: this.master_repo_app.value,
    //   method: MasterRepoStub.prototype.getSuperAdminAddress,
    //   args: [],
    //   fee: 0,
    // }).returnValue;
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:177
    // appId: this.master_repo_app.value,
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:49
    // master_repo_app = GlobalState<Application>();
    bytec 18 // "master_repo_app"
    // smart_contracts/staking/staking.algo.ts:177
    // appId: this.master_repo_app.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/staking.algo.ts:176-181
    // const superAdminResult = abiCall({
    //   appId: this.master_repo_app.value,
    //   method: MasterRepoStub.prototype.getSuperAdminAddress,
    //   args: [],
    //   fee: 0,
    // }).returnValue;
    pushbytes 0xb3b3b7e2 // method "getSuperAdminAddress()address"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:180
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:176-181
    // const superAdminResult = abiCall({
    //   appId: this.master_repo_app.value,
    //   method: MasterRepoStub.prototype.getSuperAdminAddress,
    //   args: [],
    //   fee: 0,
    // }).returnValue;
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 22 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:182
    // this.super_admin_address.value = superAdminResult;
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:184-189
    // const platformFeeResult = abiCall({
    //   appId: this.master_repo_app.value,
    //   method: MasterRepoStub.prototype.getPlatformFeeBps,
    //   args: [],
    //   fee: 0,
    // }).returnValue;
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:185
    // appId: this.master_repo_app.value,
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:49
    // master_repo_app = GlobalState<Application>();
    bytec 18 // "master_repo_app"
    // smart_contracts/staking/staking.algo.ts:185
    // appId: this.master_repo_app.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/staking.algo.ts:184-189
    // const platformFeeResult = abiCall({
    //   appId: this.master_repo_app.value,
    //   method: MasterRepoStub.prototype.getPlatformFeeBps,
    //   args: [],
    //   fee: 0,
    // }).returnValue;
    pushbytes 0xf133038d // method "getPlatformFeeBps()uint64"
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:188
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:184-189
    // const platformFeeResult = abiCall({
    //   appId: this.master_repo_app.value,
    //   method: MasterRepoStub.prototype.getPlatformFeeBps,
    //   args: [],
    //   fee: 0,
    // }).returnValue;
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 22 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/staking/staking.algo.ts:50
    // platform_fee_bps = GlobalState<Uint64>();
    bytec 15 // "platform_fee_bps"
    // smart_contracts/staking/staking.algo.ts:190
    // this.platform_fee_bps.value = platformFeeResult;
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:191
    // this.contract_state.value = new Uint64(1);
    bytec 17 // 0x0000000000000001
    app_global_put
    // smart_contracts/staking/staking.algo.ts:173
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.setContractInactive[routing]() -> void:
setContractInactive:
    // smart_contracts/staking/staking.algo.ts:196
    // assert(op.Txn.sender === this.admin_address.value || op.Txn.sender === this.super_admin_address.value, "Only admin can set inactive");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:196
    // assert(op.Txn.sender === this.admin_address.value || op.Txn.sender === this.super_admin_address.value, "Only admin can set inactive");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bnz setContractInactive_bool_true@3
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:196
    // assert(op.Txn.sender === this.admin_address.value || op.Txn.sender === this.super_admin_address.value, "Only admin can set inactive");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz setContractInactive_bool_false@4

setContractInactive_bool_true@3:
    intc_1 // 1

setContractInactive_bool_merge@5:
    // smart_contracts/staking/staking.algo.ts:196
    // assert(op.Txn.sender === this.admin_address.value || op.Txn.sender === this.super_admin_address.value, "Only admin can set inactive");
    assert // Only admin can set inactive
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:197
    // this.contract_state.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:194
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

setContractInactive_bool_false@4:
    intc_0 // 0
    b setContractInactive_bool_merge@5


// smart_contracts/staking/staking.algo.ts::Staking.updateAdminAddress[routing]() -> void:
updateAdminAddress:
    // smart_contracts/staking/staking.algo.ts:200
    // @abimethod({ allowActions: "NoOp" })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/staking/staking.algo.ts:202
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:202
    // assert(op.Txn.sender === this.admin_address.value, "Only admin can update admin address");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only admin can update admin address
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:203
    // this.admin_address.value = adminAddress;
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:200
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.updateSuperAdminAddress[routing]() -> void:
updateSuperAdminAddress:
    // smart_contracts/staking/staking.algo.ts:206
    // @abimethod({ allowActions: "NoOp" })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/staking/staking.algo.ts:208
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can update super admin address");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:208
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can update super admin address");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only super admin can update super admin address
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:209
    // this.super_admin_address.value = superAdminAddress;
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:206
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.withdrawPlatformFees[routing]() -> void:
withdrawPlatformFees:
    // smart_contracts/staking/staking.algo.ts:212
    // @abimethod({ allowActions: "NoOp" })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/staking/staking.algo.ts:214
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can withdraw fees");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:214
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can withdraw fees");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only super admin can withdraw fees
    // smart_contracts/staking/staking.algo.ts:215
    // const accrued: uint64 = this.platform_fees_accrued.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:215
    // const accrued: uint64 = this.platform_fees_accrued.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:216
    // assert(accrued > 0, "No fees accrued");
    dup
    assert // No fees accrued
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:218
    // this.platform_fees_accrued.value = new Uint64(0);
    bytec_0 // 0x0000000000000000
    app_global_put
    // smart_contracts/staking/staking.algo.ts:219-227
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: accrued,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:221
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:221
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:223
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    uncover 2
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/staking/staking.algo.ts:219-226
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: accrued,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:225
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:219-227
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: accrued,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:212
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.emergencyWithdrawAsset[routing]() -> void:
emergencyWithdrawAsset:
    pushbytes ""
    dupn 3
    // smart_contracts/staking/staking.algo.ts:230
    // @abimethod({ allowActions: "NoOp" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    cover 3
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/staking/staking.algo.ts:232
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can withdraw");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:232
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can withdraw");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only super admin can withdraw
    // smart_contracts/staking/staking.algo.ts:233
    // assert(this.contract_state.value === new Uint64(0), "Pool must be inactive");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:233
    // assert(this.contract_state.value === new Uint64(0), "Pool must be inactive");
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // 0x0000000000000000
    ==
    assert // Pool must be inactive
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    swap
    concat
    dup
    cover 3
    // smart_contracts/staking/staking.algo.ts:234
    // assert(this.stakers(receiver).exists, "No stake found for user");
    dup
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/staking/staking.algo.ts:236
    // const rec = clone(this.stakers(receiver).value);
    box_get
    pop
    // smart_contracts/staking/staking.algo.ts:237
    // const stakeNow: uint64 = rec.stake.asUint64();
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 4
    // smart_contracts/staking/staking.algo.ts:238
    // assert(stakeNow > 0, "No stake");
    dup
    assert // No stake
    // smart_contracts/staking/staking.algo.ts:239
    // assert(assetId === this.staked_asset_id.value.asUint64(), "Invalid asset");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:28
    // staked_asset_id = GlobalState<Uint64>();
    bytec 16 // "staked_asset_id"
    // smart_contracts/staking/staking.algo.ts:239
    // assert(assetId === this.staked_asset_id.value.asUint64(), "Invalid asset");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    uncover 4
    ==
    assert // Invalid asset
    // smart_contracts/staking/staking.algo.ts:240
    // assert(amount === stakeNow, "Amount mismatch");
    uncover 2
    dig 1
    ==
    assert // Amount mismatch
    // smart_contracts/staking/staking.algo.ts:242
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:242
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/staking/staking.algo.ts:242
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    uncover 2
    // smart_contracts/staking/staking.algo.ts:243
    // let pending: uint64 = accrued > rec.rewardDebt.asUint64() ? accrued - rec.rewardDebt.asUint64() : 0;
    intc_2 // 8
    extract_uint64
    dup
    cover 2
    >
    bz emergencyWithdrawAsset_ternary_false@3
    dup2
    -
    bury 6

emergencyWithdrawAsset_ternary_merge@4:
    // smart_contracts/staking/staking.algo.ts:244
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:244
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:244
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    -
    dup
    bury 8
    // smart_contracts/staking/staking.algo.ts:245
    // if (pending > payable) {
    dig 6
    <
    bz emergencyWithdrawAsset_after_if_else@6
    dig 6
    bury 6

emergencyWithdrawAsset_after_if_else@6:
    // smart_contracts/staking/staking.algo.ts:249
    // if (pending > 0) {
    dig 5
    bz emergencyWithdrawAsset_after_if_else@11
    // smart_contracts/staking/staking.algo.ts:250
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:50
    // platform_fee_bps = GlobalState<Uint64>();
    bytec 15 // "platform_fee_bps"
    // smart_contracts/staking/staking.algo.ts:250
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 6
    dup
    uncover 2
    mulw
    // smart_contracts/staking/staking.algo.ts:250
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc 5 // 10000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    bury 11
    // smart_contracts/staking/staking.algo.ts:251
    // const net: uint64 = pending - fee;
    swap
    dig 1
    -
    bury 9
    // smart_contracts/staking/staking.algo.ts:252
    // if (fee > 0) {
    bz emergencyWithdrawAsset_after_if_else@9
    // smart_contracts/staking/staking.algo.ts:253
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:253
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 9
    +
    itob
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:253
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    swap
    app_global_put

emergencyWithdrawAsset_after_if_else@9:
    // smart_contracts/staking/staking.algo.ts:255
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:255
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 6
    +
    itob
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:255
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:256-264
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:258
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:258
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:260
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 9
    itxn_field AssetAmount
    itxn_field Sender
    dig 5
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:256-263
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:262
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:256-264
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

emergencyWithdrawAsset_after_if_else@11:
    // smart_contracts/staking/staking.algo.ts:267-275
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: stakeNow,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:269
    // xferAsset: this.staked_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:28
    // staked_asset_id = GlobalState<Uint64>();
    bytec 16 // "staked_asset_id"
    // smart_contracts/staking/staking.algo.ts:269
    // xferAsset: this.staked_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:271
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 4
    dup
    cover 3
    itxn_field AssetAmount
    itxn_field Sender
    dig 6
    dup
    cover 3
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:267-274
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: stakeNow,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:273
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:267-275
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetReceiver: receiver,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: stakeNow,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:277
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() - stakeNow);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:277
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() - stakeNow);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    swap
    -
    itob
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:277
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() - stakeNow);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:278
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() - 1);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:278
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() - 1);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_1 // 1
    -
    itob
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:278
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() - 1);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:279
    // this.stakers(receiver).delete();
    dig 4
    box_del
    pop
    // smart_contracts/staking/staking.algo.ts:281-288
    // itxn
    //   .payment({
    //     receiver: receiver,
    //     amount: BOX_FEE - 2000,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:285
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Sender
    // smart_contracts/staking/staking.algo.ts:284
    // amount: BOX_FEE - 2000,
    pushint 20500 // 20500
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking/staking.algo.ts:281-287
    // itxn
    //   .payment({
    //     receiver: receiver,
    //     amount: BOX_FEE - 2000,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:286
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:281-288
    // itxn
    //   .payment({
    //     receiver: receiver,
    //     amount: BOX_FEE - 2000,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:230
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

emergencyWithdrawAsset_ternary_false@3:
    // smart_contracts/staking/staking.algo.ts:243
    // let pending: uint64 = accrued > rec.rewardDebt.asUint64() ? accrued - rec.rewardDebt.asUint64() : 0;
    intc_0 // 0
    bury 6
    b emergencyWithdrawAsset_ternary_merge@4


// smart_contracts/staking/staking.algo.ts::Staking.stake[routing]() -> void:
stake:
    pushbytes ""
    dupn 6
    // smart_contracts/staking/staking.algo.ts:353
    // @abimethod({ allowActions: "NoOp" })
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    cover 2
    txn GroupIndex
    intc_1 // 1
    -
    dup
    cover 3
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/staking/staking.algo.ts:355
    // assert(quantity > 0, "Invalid quantity");
    dup
    assert // Invalid quantity
    // smart_contracts/staking/staking.algo.ts:356
    // assert(this.contract_state.value.asUint64() === 1, "Pool is inactive");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:356
    // assert(this.contract_state.value.asUint64() === 1, "Pool is inactive");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_1 // 1
    ==
    assert // Pool is inactive
    // smart_contracts/staking/staking.algo.ts:357
    // assert(this.rewards_exhausted.value.asUint64() === 0, "Rewards exhausted");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:357
    // assert(this.rewards_exhausted.value.asUint64() === 0, "Rewards exhausted");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    !
    assert // Rewards exhausted
    // smart_contracts/staking/staking.algo.ts:358-363
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.asUint64()),
    //   assetAmount: quantity,
    // });
    dig 1
    gtxns Sender
    // smart_contracts/staking/staking.algo.ts:359
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:358-363
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.asUint64()),
    //   assetAmount: quantity,
    // });
    ==
    dig 2
    gtxns AssetReceiver
    // smart_contracts/staking/staking.algo.ts:360
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:358-363
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.asUint64()),
    //   assetAmount: quantity,
    // });
    ==
    &&
    dig 2
    gtxns XferAsset
    // smart_contracts/staking/staking.algo.ts:361
    // xferAsset: Asset(this.staked_asset_id.value.asUint64()),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:28
    // staked_asset_id = GlobalState<Uint64>();
    bytec 16 // "staked_asset_id"
    // smart_contracts/staking/staking.algo.ts:361
    // xferAsset: Asset(this.staked_asset_id.value.asUint64()),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:358-363
    // assertMatch(stakeTxn, {
    //   sender: op.Txn.sender,
    //   assetReceiver: Global.currentApplicationAddress,
    //   xferAsset: Asset(this.staked_asset_id.value.asUint64()),
    //   assetAmount: quantity,
    // });
    ==
    &&
    uncover 2
    gtxns AssetAmount
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:365
    // const exists = this.stakers(op.Txn.sender).exists;
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:365
    // const exists = this.stakers(op.Txn.sender).exists;
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/staking/staking.algo.ts:366
    // if (!exists) {
    bnz stake_else_body@3
    // smart_contracts/staking/staking.algo.ts:367-371
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    dig 1
    dup
    gtxns Sender
    // smart_contracts/staking/staking.algo.ts:368
    // sender: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:367-371
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    dig 1
    gtxns Receiver
    // smart_contracts/staking/staking.algo.ts:369
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/staking/staking.algo.ts:367-371
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    &&
    swap
    gtxns Amount
    // smart_contracts/staking/staking.algo.ts:370
    // amount: BOX_FEE,
    intc 6 // 22500
    // smart_contracts/staking/staking.algo.ts:367-371
    // assertMatch(mbrTxn, {
    //   sender: op.Txn.sender,
    //   receiver: Global.currentApplicationAddress,
    //   amount: BOX_FEE,
    // });
    ==
    &&
    assert // assert target is match for conditions

stake_after_if_else@5:
    // smart_contracts/staking/staking.algo.ts:384
    // this.updatePool();
    callsub updatePool
    // smart_contracts/staking/staking.algo.ts:386
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.asUint64() : 0;
    dup
    bz stake_ternary_false@7
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:386
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.asUint64() : 0;
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:386
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.asUint64() : 0;
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    bury 4

stake_ternary_merge@8:
    // smart_contracts/staking/staking.algo.ts:387
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.asUint64() : 0;
    dup
    bz stake_ternary_false@10
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:387
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.asUint64() : 0;
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:387
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.asUint64() : 0;
    box_get
    assert // Box must have value
    intc_2 // 8
    extract_uint64
    bury 5

stake_ternary_merge@11:
    // smart_contracts/staking/staking.algo.ts:388
    // const accrued = mulDivW(prevStake, this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:388
    // const accrued = mulDivW(prevStake, this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 4
    mulw
    // smart_contracts/staking/staking.algo.ts:388
    // const accrued = mulDivW(prevStake, this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    bury 11
    // smart_contracts/staking/staking.algo.ts:389
    // let pending: uint64 = accrued > prevDebt ? accrued - prevDebt : 0;
    dig 5
    >
    bz stake_ternary_false@13
    dig 9
    dig 5
    -
    bury 6

stake_ternary_merge@14:
    // smart_contracts/staking/staking.algo.ts:390
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:390
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:390
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    -
    dup
    bury 8
    // smart_contracts/staking/staking.algo.ts:391
    // if (pending > payable) {
    dig 6
    <
    bz stake_after_if_else@16
    dig 6
    bury 6

stake_after_if_else@16:
    // smart_contracts/staking/staking.algo.ts:395
    // if (pending > 0) {
    dig 5
    bz stake_after_if_else@21
    // smart_contracts/staking/staking.algo.ts:396
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:50
    // platform_fee_bps = GlobalState<Uint64>();
    bytec 15 // "platform_fee_bps"
    // smart_contracts/staking/staking.algo.ts:396
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 6
    dup
    uncover 2
    mulw
    // smart_contracts/staking/staking.algo.ts:396
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc 5 // 10000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    bury 11
    // smart_contracts/staking/staking.algo.ts:397
    // const net: uint64 = pending - fee;
    swap
    dig 1
    -
    bury 9
    // smart_contracts/staking/staking.algo.ts:398
    // if (fee > 0) {
    bz stake_after_if_else@19
    // smart_contracts/staking/staking.algo.ts:399
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:399
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 9
    +
    itob
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:399
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    swap
    app_global_put

stake_after_if_else@19:
    // smart_contracts/staking/staking.algo.ts:401
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:401
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 6
    +
    itob
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:401
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:402-410
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:404
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:404
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:405
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:406
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 10
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:402-409
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:408
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:402-410
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

stake_after_if_else@21:
    // smart_contracts/staking/staking.algo.ts:413
    // const newStake: uint64 = prevStake + quantity;
    dig 3
    dig 3
    dup
    cover 2
    +
    // smart_contracts/staking/staking.algo.ts:414
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() + quantity);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:414
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() + quantity);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    uncover 2
    +
    itob
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:414
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() + quantity);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:416
    // const newDebt = mulDivW(newStake, this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:416
    // const newDebt = mulDivW(newStake, this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 1
    mulw
    // smart_contracts/staking/staking.algo.ts:416
    // const newDebt = mulDivW(newStake, this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/staking/staking.algo.ts:418
    // stake: new Uint64(newStake),
    swap
    itob
    // smart_contracts/staking/staking.algo.ts:419
    // rewardDebt: new Uint64(newDebt),
    swap
    itob
    // smart_contracts/staking/staking.algo.ts:417-420
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new Uint64(newStake),
    //   rewardDebt: new Uint64(newDebt),
    // });
    concat
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:417
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:417-420
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new Uint64(newStake),
    //   rewardDebt: new Uint64(newDebt),
    // });
    swap
    box_put
    // smart_contracts/staking/staking.algo.ts:422
    // if (!exists) {
    dup
    bnz stake_after_if_else@23
    // smart_contracts/staking/staking.algo.ts:423
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() + 1);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:423
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() + 1);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_1 // 1
    +
    itob
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:423
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() + 1);
    swap
    app_global_put

stake_after_if_else@23:
    // smart_contracts/staking/staking.algo.ts:353
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

stake_ternary_false@13:
    // smart_contracts/staking/staking.algo.ts:389
    // let pending: uint64 = accrued > prevDebt ? accrued - prevDebt : 0;
    intc_0 // 0
    bury 6
    b stake_ternary_merge@14

stake_ternary_false@10:
    // smart_contracts/staking/staking.algo.ts:387
    // const prevDebt: uint64 = exists ? this.stakers(op.Txn.sender).value.rewardDebt.asUint64() : 0;
    intc_0 // 0
    bury 5
    b stake_ternary_merge@11

stake_ternary_false@7:
    // smart_contracts/staking/staking.algo.ts:386
    // const prevStake: uint64 = exists ? this.stakers(op.Txn.sender).value.stake.asUint64() : 0;
    intc_0 // 0
    bury 4
    b stake_ternary_merge@8

stake_else_body@3:
    // smart_contracts/staking/staking.algo.ts:374-381
    // itxn
    //   .payment({
    //     receiver: op.Txn.sender,
    //     amount: BOX_FEE,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:376
    // receiver: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:378
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Sender
    // smart_contracts/staking/staking.algo.ts:377
    // amount: BOX_FEE,
    intc 6 // 22500
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking/staking.algo.ts:374-380
    // itxn
    //   .payment({
    //     receiver: op.Txn.sender,
    //     amount: BOX_FEE,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:379
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:374-381
    // itxn
    //   .payment({
    //     receiver: op.Txn.sender,
    //     amount: BOX_FEE,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    b stake_after_if_else@5


// smart_contracts/staking/staking.algo.ts::Staking.claimRewards[routing]() -> void:
claimRewards:
    pushbytes ""
    dupn 3
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:429
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:429
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/staking/staking.algo.ts:430
    // assert(this.contract_state.value.asUint64() === 1, "Pool is inactive");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:430
    // assert(this.contract_state.value.asUint64() === 1, "Pool is inactive");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_1 // 1
    ==
    assert // Pool is inactive
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:431
    // const staker = clone(this.stakers(op.Txn.sender).value);
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:431
    // const staker = clone(this.stakers(op.Txn.sender).value);
    box_get
    assert // Box must have value
    // smart_contracts/staking/staking.algo.ts:432
    // assert(staker.stake.asUint64() > 0, "No stake");
    dup
    extract 0 8
    swap
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    dup
    assert // No stake
    // smart_contracts/staking/staking.algo.ts:434
    // this.updatePool();
    callsub updatePool
    // smart_contracts/staking/staking.algo.ts:436
    // const accrued = mulDivW(staker.stake.asUint64(), this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:436
    // const accrued = mulDivW(staker.stake.asUint64(), this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/staking/staking.algo.ts:436
    // const accrued = mulDivW(staker.stake.asUint64(), this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    uncover 2
    // smart_contracts/staking/staking.algo.ts:437
    // let pending: uint64 = accrued > staker.rewardDebt.asUint64() ? accrued - staker.rewardDebt.asUint64() : 0;
    intc_2 // 8
    extract_uint64
    dup
    cover 2
    >
    bz claimRewards_ternary_false@3
    dup2
    -
    bury 5

claimRewards_ternary_merge@4:
    // smart_contracts/staking/staking.algo.ts:438
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:438
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:438
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    -
    dup
    bury 7
    // smart_contracts/staking/staking.algo.ts:439
    // if (pending > payable) {
    dig 5
    <
    bz claimRewards_after_if_else@6
    dig 5
    bury 5

claimRewards_after_if_else@6:
    // smart_contracts/staking/staking.algo.ts:443
    // if (pending > 0) {
    dig 4
    bz claimRewards_after_if_else@11
    // smart_contracts/staking/staking.algo.ts:444
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:50
    // platform_fee_bps = GlobalState<Uint64>();
    bytec 15 // "platform_fee_bps"
    // smart_contracts/staking/staking.algo.ts:444
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 5
    dup
    uncover 2
    mulw
    // smart_contracts/staking/staking.algo.ts:444
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc 5 // 10000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    bury 10
    // smart_contracts/staking/staking.algo.ts:445
    // const net: uint64 = pending - fee;
    swap
    dig 1
    -
    bury 8
    // smart_contracts/staking/staking.algo.ts:446
    // if (fee > 0) {
    bz claimRewards_after_if_else@9
    // smart_contracts/staking/staking.algo.ts:447
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:447
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 8
    +
    itob
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:447
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    swap
    app_global_put

claimRewards_after_if_else@9:
    // smart_contracts/staking/staking.algo.ts:449
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:449
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 5
    +
    itob
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:449
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:450-458
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:452
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:452
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:453
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:454
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 9
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:450-457
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:456
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:450-458
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

claimRewards_after_if_else@11:
    // smart_contracts/staking/staking.algo.ts:461
    // const newDebt = mulDivW(staker.stake.asUint64(), this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:461
    // const newDebt = mulDivW(staker.stake.asUint64(), this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 3
    mulw
    // smart_contracts/staking/staking.algo.ts:461
    // const newDebt = mulDivW(staker.stake.asUint64(), this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/staking/staking.algo.ts:464
    // rewardDebt: new Uint64(newDebt),
    itob
    // smart_contracts/staking/staking.algo.ts:462-465
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: staker.stake,
    //   rewardDebt: new Uint64(newDebt),
    // });
    dig 4
    swap
    concat
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:462
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:462-465
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: staker.stake,
    //   rewardDebt: new Uint64(newDebt),
    // });
    swap
    box_put
    // smart_contracts/staking/staking.algo.ts:427
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

claimRewards_ternary_false@3:
    // smart_contracts/staking/staking.algo.ts:437
    // let pending: uint64 = accrued > staker.rewardDebt.asUint64() ? accrued - staker.rewardDebt.asUint64() : 0;
    intc_0 // 0
    bury 5
    b claimRewards_ternary_merge@4


// smart_contracts/staking/staking.algo.ts::Staking.unstake[routing]() -> void:
unstake:
    pushbytes ""
    dupn 4
    // smart_contracts/staking/staking.algo.ts:468
    // @abimethod({ allowActions: "NoOp" })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:470
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:470
    // assert(this.stakers(op.Txn.sender).exists, "No stake found for user");
    box_len
    bury 1
    assert // No stake found for user
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:471
    // const rec = clone(this.stakers(op.Txn.sender).value);
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:471
    // const rec = clone(this.stakers(op.Txn.sender).value);
    box_get
    assert // Box must have value
    // smart_contracts/staking/staking.algo.ts:472
    // const stakeNow: uint64 = rec.stake.asUint64();
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 3
    // smart_contracts/staking/staking.algo.ts:473
    // assert(stakeNow > 0, "No stake");
    dup
    assert // No stake
    // smart_contracts/staking/staking.algo.ts:475
    // this.updatePool();
    callsub updatePool
    // smart_contracts/staking/staking.algo.ts:477
    // const amountToWithdraw: uint64 = quantity === 0 ? stakeNow : quantity;
    dig 2
    !
    uncover 3
    dig 2
    uncover 2
    select
    dup
    cover 3
    // smart_contracts/staking/staking.algo.ts:478
    // assert(stakeNow >= amountToWithdraw, "Unstake amount exceeds balance");
    dig 1
    <=
    assert // Unstake amount exceeds balance
    // smart_contracts/staking/staking.algo.ts:480
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:480
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/staking/staking.algo.ts:480
    // const accrued = mulDivW(stakeNow, this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    uncover 2
    // smart_contracts/staking/staking.algo.ts:481
    // let pending: uint64 = accrued > rec.rewardDebt.asUint64() ? accrued - rec.rewardDebt.asUint64() : 0;
    intc_2 // 8
    extract_uint64
    dup
    cover 2
    >
    bz unstake_ternary_false@3
    dup2
    -
    bury 6

unstake_ternary_merge@4:
    // smart_contracts/staking/staking.algo.ts:482
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:482
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:482
    // const payable: uint64 = this.accrued_rewards.value.asUint64() - this.rewards_paid.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    -
    dup
    bury 8
    // smart_contracts/staking/staking.algo.ts:483
    // if (pending > payable) {
    dig 6
    <
    bz unstake_after_if_else@6
    dig 6
    bury 6

unstake_after_if_else@6:
    // smart_contracts/staking/staking.algo.ts:487
    // if (pending > 0) {
    dig 5
    bz unstake_after_if_else@11
    // smart_contracts/staking/staking.algo.ts:488
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:50
    // platform_fee_bps = GlobalState<Uint64>();
    bytec 15 // "platform_fee_bps"
    // smart_contracts/staking/staking.algo.ts:488
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 6
    dup
    uncover 2
    mulw
    // smart_contracts/staking/staking.algo.ts:488
    // const fee: uint64 = mulDivW(pending, this.platform_fee_bps.value.asUint64(), 10_000);
    intc 5 // 10000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    dup
    bury 11
    // smart_contracts/staking/staking.algo.ts:489
    // const net: uint64 = pending - fee;
    swap
    dig 1
    -
    bury 9
    // smart_contracts/staking/staking.algo.ts:490
    // if (fee > 0) {
    bz unstake_after_if_else@9
    // smart_contracts/staking/staking.algo.ts:491
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:491
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 9
    +
    itob
    // smart_contracts/staking/staking.algo.ts:51
    // platform_fees_accrued = GlobalState<Uint64>();
    bytec_2 // "platform_fees_accrued"
    // smart_contracts/staking/staking.algo.ts:491
    // this.platform_fees_accrued.value = new Uint64(this.platform_fees_accrued.value.asUint64() + fee);
    swap
    app_global_put

unstake_after_if_else@9:
    // smart_contracts/staking/staking.algo.ts:493
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:493
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 6
    +
    itob
    // smart_contracts/staking/staking.algo.ts:42
    // rewards_paid = GlobalState<Uint64>();
    bytec_1 // "rewards_paid"
    // smart_contracts/staking/staking.algo.ts:493
    // this.rewards_paid.value = new Uint64(this.rewards_paid.value.asUint64() + pending);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:494-502
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:496
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:496
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:497
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:498
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 10
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:494-501
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:500
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:494-502
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: net,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

unstake_after_if_else@11:
    // smart_contracts/staking/staking.algo.ts:505-513
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: amountToWithdraw,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:507
    // xferAsset: this.staked_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:28
    // staked_asset_id = GlobalState<Uint64>();
    bytec 16 // "staked_asset_id"
    // smart_contracts/staking/staking.algo.ts:507
    // xferAsset: this.staked_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:508
    // assetReceiver: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:509
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    dig 5
    dup
    cover 4
    itxn_field AssetAmount
    itxn_field Sender
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:505-512
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: amountToWithdraw,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:511
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:505-513
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetReceiver: op.Txn.sender,
    //     sender: Global.currentApplicationAddress,
    //     assetAmount: amountToWithdraw,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:515
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() - amountToWithdraw);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:515
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() - amountToWithdraw);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dig 1
    -
    itob
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:515
    // this.total_staked.value = new Uint64(this.total_staked.value.asUint64() - amountToWithdraw);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:517
    // const remaining: uint64 = stakeNow - amountToWithdraw;
    dig 4
    swap
    -
    dup
    bury 6
    // smart_contracts/staking/staking.algo.ts:518
    // if (remaining === 0) {
    bnz unstake_else_body@15
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:519
    // this.stakers(op.Txn.sender).delete();
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:519
    // this.stakers(op.Txn.sender).delete();
    box_del
    pop
    // smart_contracts/staking/staking.algo.ts:520
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() - 1);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:520
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() - 1);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_1 // 1
    -
    itob
    // smart_contracts/staking/staking.algo.ts:46
    // num_stakers = GlobalState<Uint64>();
    bytec 13 // "num_stakers"
    // smart_contracts/staking/staking.algo.ts:520
    // this.num_stakers.value = new Uint64(this.num_stakers.value.asUint64() - 1);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:521-528
    // itxn
    //   .payment({
    //     receiver: op.Txn.sender,
    //     amount: BOX_FEE,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:523
    // receiver: op.Txn.sender,
    txn Sender
    // smart_contracts/staking/staking.algo.ts:525
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field Sender
    // smart_contracts/staking/staking.algo.ts:524
    // amount: BOX_FEE,
    intc 6 // 22500
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/staking/staking.algo.ts:521-527
    // itxn
    //   .payment({
    //     receiver: op.Txn.sender,
    //     amount: BOX_FEE,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:526
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:521-528
    // itxn
    //   .payment({
    //     receiver: op.Txn.sender,
    //     amount: BOX_FEE,
    //     sender: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

unstake_after_if_else@16:
    // smart_contracts/staking/staking.algo.ts:468
    // @abimethod({ allowActions: "NoOp" })
    intc_1 // 1
    return

unstake_else_body@15:
    // smart_contracts/staking/staking.algo.ts:530
    // const newDebt = mulDivW(remaining, this.reward_per_token.value.asUint64(), PRECISION);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:530
    // const newDebt = mulDivW(remaining, this.reward_per_token.value.asUint64(), PRECISION);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    dig 5
    dup
    uncover 2
    mulw
    // smart_contracts/staking/staking.algo.ts:530
    // const newDebt = mulDivW(remaining, this.reward_per_token.value.asUint64(), PRECISION);
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/staking/staking.algo.ts:532
    // stake: new Uint64(remaining),
    swap
    itob
    // smart_contracts/staking/staking.algo.ts:533
    // rewardDebt: new Uint64(newDebt),
    swap
    itob
    // smart_contracts/staking/staking.algo.ts:531-534
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new Uint64(remaining),
    //   rewardDebt: new Uint64(newDebt),
    // });
    concat
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    bytec_3 // "st"
    // smart_contracts/staking/staking.algo.ts:531
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    txn Sender
    // smart_contracts/staking/staking.algo.ts:26
    // stakers = BoxMap<Account, StakeInfoRecord>({ keyPrefix: "st" });
    concat
    // smart_contracts/staking/staking.algo.ts:531-534
    // this.stakers(op.Txn.sender).value = new StakeInfoRecord({
    //   stake: new Uint64(remaining),
    //   rewardDebt: new Uint64(newDebt),
    // });
    swap
    box_put
    b unstake_after_if_else@16

unstake_ternary_false@3:
    // smart_contracts/staking/staking.algo.ts:481
    // let pending: uint64 = accrued > rec.rewardDebt.asUint64() ? accrued - rec.rewardDebt.asUint64() : 0;
    intc_0 // 0
    bury 6
    b unstake_ternary_merge@4


// smart_contracts/staking/staking.algo.ts::Staking.deleteApplication[routing]() -> void:
deleteApplication:
    // smart_contracts/staking/staking.algo.ts:540
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can delete application");
    txn Sender
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:45
    // super_admin_address = GlobalState<Account>();
    bytec 14 // "super_admin_address"
    // smart_contracts/staking/staking.algo.ts:540
    // assert(op.Txn.sender === this.super_admin_address.value, "Only super admin can delete application");
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only super admin can delete application
    // smart_contracts/staking/staking.algo.ts:541
    // assert(this.total_staked.value.asUint64() === 0, "Staked assets still exist");
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:541
    // assert(this.total_staked.value.asUint64() === 0, "Staked assets still exist");
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    !
    assert // Staked assets still exist
    // smart_contracts/staking/staking.algo.ts:543-551
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetCloseTo: this.admin_address.value,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:545
    // xferAsset: this.staked_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:28
    // staked_asset_id = GlobalState<Uint64>();
    bytec 16 // "staked_asset_id"
    // smart_contracts/staking/staking.algo.ts:545
    // xferAsset: this.staked_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    dup
    btoi
    // smart_contracts/staking/staking.algo.ts:546
    // assetCloseTo: this.admin_address.value,
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:546
    // assetCloseTo: this.admin_address.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/staking.algo.ts:548
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/staking/staking.algo.ts:547
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:543-550
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetCloseTo: this.admin_address.value,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:549
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:543-551
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.staked_asset_id.value.asUint64(),
    //     assetCloseTo: this.admin_address.value,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/staking/staking.algo.ts:553
    // if (this.staked_asset_id.value !== this.reward_asset_id.value) {
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:553
    // if (this.staked_asset_id.value !== this.reward_asset_id.value) {
    app_global_get_ex
    assert // check GlobalState exists
    !=
    bz deleteApplication_after_if_else@5
    // smart_contracts/staking/staking.algo.ts:554-562
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetCloseTo: this.admin_address.value,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/staking/staking.algo.ts:556
    // xferAsset: this.reward_asset_id.value.asUint64(),
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:29
    // reward_asset_id = GlobalState<Uint64>();
    bytec 5 // "reward_asset_id"
    // smart_contracts/staking/staking.algo.ts:556
    // xferAsset: this.reward_asset_id.value.asUint64(),
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/staking.algo.ts:557
    // assetCloseTo: this.admin_address.value,
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:44
    // admin_address = GlobalState<Account>();
    bytec 4 // "admin_address"
    // smart_contracts/staking/staking.algo.ts:557
    // assetCloseTo: this.admin_address.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/staking/staking.algo.ts:559
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/staking/staking.algo.ts:558
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetCloseTo
    itxn_field XferAsset
    // smart_contracts/staking/staking.algo.ts:554-561
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetCloseTo: this.admin_address.value,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_3 // 4
    itxn_field TypeEnum
    // smart_contracts/staking/staking.algo.ts:560
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/staking/staking.algo.ts:554-562
    // itxn
    //   .assetTransfer({
    //     xferAsset: this.reward_asset_id.value.asUint64(),
    //     assetCloseTo: this.admin_address.value,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit

deleteApplication_after_if_else@5:
    // smart_contracts/staking/staking.algo.ts:538
    // @abimethod({ allowActions: "DeleteApplication" })
    intc_1 // 1
    return


// smart_contracts/staking/staking.algo.ts::Staking.updatePool() -> void:
updatePool:
    // smart_contracts/staking/staking.algo.ts:291
    // private updatePool(): void {
    proto 0 0
    pushbytes ""
    dupn 5
    // smart_contracts/staking/staking.algo.ts:292
    // if (this.contract_state.value === new Uint64(0)) {
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:48
    // contract_state = GlobalState<Uint64>(); // 0 = inactive, 1 = active
    bytec 9 // "contract_state"
    // smart_contracts/staking/staking.algo.ts:292
    // if (this.contract_state.value === new Uint64(0)) {
    app_global_get_ex
    assert // check GlobalState exists
    bytec_0 // 0x0000000000000000
    ==
    bz updatePool_after_if_else@2
    // smart_contracts/staking/staking.algo.ts:293
    // return;
    retsub

updatePool_after_if_else@2:
    // smart_contracts/staking/staking.algo.ts:296
    // const now: uint64 = Global.latestTimestamp;
    global LatestTimestamp
    dup
    frame_bury 2
    // smart_contracts/staking/staking.algo.ts:297
    // const start: uint64 = this.start_time.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:35
    // start_time = GlobalState<Uint64>();
    bytec 20 // "start_time"
    // smart_contracts/staking/staking.algo.ts:297
    // const start: uint64 = this.start_time.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    frame_bury 5
    // smart_contracts/staking/staking.algo.ts:298
    // const last: uint64 = this.last_update_time.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:298
    // const last: uint64 = this.last_update_time.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    dup
    frame_bury 1
    // smart_contracts/staking/staking.algo.ts:300
    // if (now <= last) {
    <=
    bz updatePool_after_if_else@4
    // smart_contracts/staking/staking.algo.ts:301
    // return;
    retsub

updatePool_after_if_else@4:
    // smart_contracts/staking/staking.algo.ts:304
    // if (this.rewards_exhausted.value.asUint64() === 1) {
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:304
    // if (this.rewards_exhausted.value.asUint64() === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_1 // 1
    ==
    bz updatePool_after_if_else@6
    // smart_contracts/staking/staking.algo.ts:305
    // this.last_update_time.value = new Uint64(now);
    frame_dig 2
    itob
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:305
    // this.last_update_time.value = new Uint64(now);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:306
    // return;
    retsub

updatePool_after_if_else@6:
    // smart_contracts/staking/staking.algo.ts:310
    // if (cappedTime <= start) {
    frame_dig 2
    frame_dig 5
    <=
    bz updatePool_after_if_else@8
    // smart_contracts/staking/staking.algo.ts:311
    // this.last_update_time.value = new Uint64(cappedTime);
    frame_dig 2
    itob
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:311
    // this.last_update_time.value = new Uint64(cappedTime);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:312
    // return;
    retsub

updatePool_after_if_else@8:
    // smart_contracts/staking/staking.algo.ts:315
    // const effectiveLast: uint64 = last < start ? start : last;
    frame_dig 1
    dup
    frame_dig 5
    dup
    cover 3
    <
    swap
    cover 2
    select
    dup
    frame_bury 0
    // smart_contracts/staking/staking.algo.ts:316
    // if (cappedTime <= effectiveLast) {
    frame_dig 2
    >=
    bz updatePool_after_if_else@10
    // smart_contracts/staking/staking.algo.ts:317
    // this.last_update_time.value = new Uint64(cappedTime);
    frame_dig 2
    itob
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:317
    // this.last_update_time.value = new Uint64(cappedTime);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:318
    // return;
    retsub

updatePool_after_if_else@10:
    // smart_contracts/staking/staking.algo.ts:321
    // if (this.total_staked.value.asUint64() === 0) {
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:321
    // if (this.total_staked.value.asUint64() === 0) {
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    bnz updatePool_after_if_else@12
    // smart_contracts/staking/staking.algo.ts:322
    // this.last_update_time.value = new Uint64(cappedTime);
    frame_dig 2
    itob
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:322
    // this.last_update_time.value = new Uint64(cappedTime);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:323
    // return;
    retsub

updatePool_after_if_else@12:
    // smart_contracts/staking/staking.algo.ts:326
    // const duration: uint64 = cappedTime - effectiveLast;
    frame_dig 2
    frame_dig 0
    -
    // smart_contracts/staking/staking.algo.ts:327
    // let rewardRate: uint64 = this.reward_rate.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:34
    // reward_rate = GlobalState<Uint64>();
    bytec 19 // "reward_rate"
    // smart_contracts/staking/staking.algo.ts:327
    // let rewardRate: uint64 = this.reward_rate.value.asUint64();
    app_global_get_ex
    bury 1
    assert // check GlobalState exists
    // smart_contracts/staking/staking.algo.ts:328
    // const annualReward = mulDivW(this.total_staked.value.asUint64(), this.apr_bps.value.asUint64(), 10_000);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:328
    // const annualReward = mulDivW(this.total_staked.value.asUint64(), this.apr_bps.value.asUint64(), 10_000);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:40
    // apr_bps = GlobalState<Uint64>();
    bytec 21 // "apr_bps"
    // smart_contracts/staking/staking.algo.ts:328
    // const annualReward = mulDivW(this.total_staked.value.asUint64(), this.apr_bps.value.asUint64(), 10_000);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/staking/staking.algo.ts:328
    // const annualReward = mulDivW(this.total_staked.value.asUint64(), this.apr_bps.value.asUint64(), 10_000);
    intc 5 // 10000
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    divw
    // smart_contracts/staking/staking.algo.ts:329
    // rewardRate = annualReward / SECONDS_PER_YEAR;
    pushint 31536000 // 31536000
    /
    // smart_contracts/staking/staking.algo.ts:331
    // let reward: uint64 = duration * rewardRate;
    *
    dup
    frame_bury 4
    // smart_contracts/staking/staking.algo.ts:332
    // const remaining: uint64 = this.total_rewards.value.asUint64() - this.accrued_rewards.value.asUint64();
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:332
    // const remaining: uint64 = this.total_rewards.value.asUint64() - this.accrued_rewards.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:332
    // const remaining: uint64 = this.total_rewards.value.asUint64() - this.accrued_rewards.value.asUint64();
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    -
    dup
    frame_bury 3
    // smart_contracts/staking/staking.algo.ts:333
    // if (reward > remaining) {
    >
    bz updatePool_after_if_else@14
    frame_dig 3
    frame_bury 4

updatePool_after_if_else@14:
    // smart_contracts/staking/staking.algo.ts:336
    // if (reward === 0) {
    frame_dig 4
    bnz updatePool_after_if_else@18
    // smart_contracts/staking/staking.algo.ts:337
    // if (remaining === 0) {
    frame_dig 3
    bnz updatePool_after_if_else@17
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:338
    // this.rewards_exhausted.value = new Uint64(1);
    bytec 17 // 0x0000000000000001
    app_global_put

updatePool_after_if_else@17:
    // smart_contracts/staking/staking.algo.ts:340
    // this.last_update_time.value = new Uint64(cappedTime);
    frame_dig 2
    itob
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:340
    // this.last_update_time.value = new Uint64(cappedTime);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:341
    // return;
    retsub

updatePool_after_if_else@18:
    // smart_contracts/staking/staking.algo.ts:344
    // this.accrued_rewards.value = new Uint64(this.accrued_rewards.value.asUint64() + reward);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:344
    // this.accrued_rewards.value = new Uint64(this.accrued_rewards.value.asUint64() + reward);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    frame_dig 4
    dup
    cover 2
    +
    itob
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:344
    // this.accrued_rewards.value = new Uint64(this.accrued_rewards.value.asUint64() + reward);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:345
    // const deltaRPT = mulDivW(reward, PRECISION, this.total_staked.value.asUint64());
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:31
    // total_staked = GlobalState<Uint64>();
    bytec 6 // "total_staked"
    // smart_contracts/staking/staking.algo.ts:345
    // const deltaRPT = mulDivW(reward, PRECISION, this.total_staked.value.asUint64());
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    // smart_contracts/staking/config.algo.ts:27
    // assert(c > 0, "mulDivW: division by zero");
    dup
    assert // mulDivW: division by zero
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    swap
    // smart_contracts/staking/staking.algo.ts:345
    // const deltaRPT = mulDivW(reward, PRECISION, this.total_staked.value.asUint64());
    intc 4 // 1000000000000000
    // smart_contracts/staking/config.algo.ts:28
    // const [hi, lo] = mulw(a, b);
    mulw
    // smart_contracts/staking/config.algo.ts:29
    // return divw(hi, lo, c);
    uncover 2
    divw
    // smart_contracts/staking/staking.algo.ts:346
    // this.reward_per_token.value = new Uint64(this.reward_per_token.value.asUint64() + deltaRPT);
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:346
    // this.reward_per_token.value = new Uint64(this.reward_per_token.value.asUint64() + deltaRPT);
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    +
    itob
    // smart_contracts/staking/staking.algo.ts:32
    // reward_per_token = GlobalState<Uint64>();
    bytec 8 // "reward_per_token"
    // smart_contracts/staking/staking.algo.ts:346
    // this.reward_per_token.value = new Uint64(this.reward_per_token.value.asUint64() + deltaRPT);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:347
    // this.last_update_time.value = new Uint64(cappedTime);
    frame_dig 2
    itob
    // smart_contracts/staking/staking.algo.ts:36
    // last_update_time = GlobalState<Uint64>();
    bytec 10 // "last_update_time"
    // smart_contracts/staking/staking.algo.ts:347
    // this.last_update_time.value = new Uint64(cappedTime);
    swap
    app_global_put
    // smart_contracts/staking/staking.algo.ts:348
    // if (this.accrued_rewards.value.asUint64() === this.total_rewards.value.asUint64()) {
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:39
    // accrued_rewards = GlobalState<Uint64>();
    bytec 7 // "accrued_rewards"
    // smart_contracts/staking/staking.algo.ts:348
    // if (this.accrued_rewards.value.asUint64() === this.total_rewards.value.asUint64()) {
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    intc_0 // 0
    // smart_contracts/staking/staking.algo.ts:38
    // total_rewards = GlobalState<Uint64>();
    bytec 12 // "total_rewards"
    // smart_contracts/staking/staking.algo.ts:348
    // if (this.accrued_rewards.value.asUint64() === this.total_rewards.value.asUint64()) {
    app_global_get_ex
    assert // check GlobalState exists
    btoi
    ==
    bz updatePool_after_if_else@20
    // smart_contracts/staking/staking.algo.ts:41
    // rewards_exhausted = GlobalState<Uint64>();
    bytec 11 // "rewards_exhausted"
    // smart_contracts/staking/staking.algo.ts:349
    // this.rewards_exhausted.value = new Uint64(1);
    bytec 17 // 0x0000000000000001
    app_global_put

updatePool_after_if_else@20:
    retsub
